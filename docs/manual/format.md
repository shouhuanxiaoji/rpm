---
layout: default
title: rpm.org - RPM软件包格式
---
# Package format

本文件描述了RPM文件格式3.0版，它被RPM 2.1版和更高版本所使用。 该格式可能会发生变化，你不应该认为这个文件是与最新的RPM代码保持同步的。 也就是说，3.0的格式应该在相当长的一段时间内不会改变，而当它改变时，它将不再是3.0 :-)。

\警告 在任何情况下，访问这些结构的正确方式是通过RPM库！。

RPM文件格式包括源代码和二进制包。 一个RPM包文件被分为4个逻辑部分。

```
. Lead      -- 96 bytes of "magic" and other info
. Signature -- collection of "digital signatures"
. Header    -- holding area for all the package information (aka "metadata")
. Payload   -- compressed archive of the file(s) in the package (aka "payload")
```

所有2字节和4字节的 "整型" 数据（int16和int32）都以网络字节顺序存储。 当数据呈现时，第一个数字是十六进制的字节编号或地址，接着是十六进制的字节值，然后是字符 "翻译"（适当时）。

## Lead

Lead基本上是用于文件(1)。 所有包含在Lead中的信息都被Header中的信息所重复或取代。

Lead中的许多信息在RPM的旧版本中被使用，但现在被忽略了。 Lead被存储为一个C结构:

\code
struct rpmlead {
    unsigned char magic[4];
    unsigned char major, minor;
    short type;
    short archnum;
    char name[66];
    short osnum;
    short signature_type;
    char reserved[16];
};
\endcode

并用从 rpm-2.1.2-1.i386.rpm 包中提取的一个进行说明：

```
00000000: ed ab ee db 03 00 00 00
```

前 4 个字节 (0-3) 是“magic”，用于唯一标识 RPM 包。 它供 RPM 和 file(1) 使用。 接下来的两个字节（4、5）是 int8 数据，表示“主要”和“次要”RPM 文件格式版本。 此软件包为 3.0 格式。 接下来的两个字节 (6-7) 形成一个 int16，指示包类型。 在撰写本文时只有两种类型：0 == 二进制，1 == 源代码。

```
00000008: 00 01 72 70 6d 2d 32 2e    ..rpm-2.
```

再接下来的两个字节 (8-9) 形成一个 int16，表示构建包的架构。虽然这由 file(1) 使用，但真正的体系结构作为字符串存储在 Header 中。 请参阅 lib/misc.c 以获取 架构->int16 翻译的列表。在这里，1 == i386。
从字节 10 开始并扩展到字节 75，是 65 个字符和一个空字节，其中包含熟悉的包的“名称-版本-发布”，用null (0)字节填充。

```
00000010: 31 2e 32 2d 31 00 00 00    1.2-1...
00000018: 00 00 00 00 00 00 00 00    ........
00000020: 00 00 00 00 00 00 00 00    ........
00000028: 00 00 00 00 00 00 00 00    ........
00000030: 00 00 00 00 00 00 00 00    ........
00000038: 00 00 00 00 00 00 00 00    ........
00000040: 00 00 00 00 00 00 00 00    ........
00000048: 00 00 00 00 00 01 00 05    ........
```

字节 76-77（上面的“00 01”）形成一个 int16，指示构建包的操作系统。 在这种情况下，1 == Linux。 接下来的 2 个字节 (78-79) 形成一个 int16，指示签名类型。 这告诉 RPM 在签名中期望什么。 对于版本 3.0 包，这是 5，表示新的“header样式”签名。

```
00000050: 04 00 00 00 68 e6 ff bf    ........
00000058: ab ad 00 08 3c eb ff bf    ........
```

剩余的 16 个字节 (80-95) 当前未使用，保留用于未来扩展。

## Signature

3.0 格式的签名（在 Lead 中由签名类型 5 表示）使用与 Header 相同的结构。 由于历史原因，这种结构被称为“header结构”，由于它同时用于Header和Signature，因此可能会造成混淆。 下面给出了标题结构的详细信息，您需要阅读它们，以便其余部分有意义。 Signature的标签在 lib/signature.h 中定义。

Signature可以包含多个不同类型的签名。 目前只有三种类型，每种在头部结构中都有自己的标签：

```
	Name	Tag	Header Type
	----	----	-----------
	SIZE	1000	INT_32
	MD5	1001	BIN
	PGP	1002	BIN
```

MD5 签名为 16 字节，PGP 签名随用于对包进行签名的 PGP 密钥的大小而变化。

从 RPM 2.1 开始，所有包都至少带有 SIZE 和 MD5 签名，并且 Signature 部分被填充为 8 字节的倍数。

## Header

Header 包含了一个包的所有信息：名称、版本、文件列表等。它使用与 Signature 相同的“头结构”，下面将详细介绍。 Header的完整标签列表将占用太多空间，并且列表增长相当频繁。 有关完整列表，请参见 RPM 源代码中的 lib/rpmlib.h。

## Payload

Payload 当前是一个 gzip 压缩的 cpio 存档。 使用的 cpio 存档类型是带有 CRC 校验和的 SVR4。

## The Header Structure

header结构有点复杂，但实际上执行了一个非常简单的功能。 它的行为几乎就像一个小型数据库，因为它允许您使用称为“标签”的键存储和检索任意数据。 当头结构写入磁盘时，数据以网络字节顺序写入，当从磁盘读取时，转换为主机字节顺序。

与标签和数据一起，存储了数据“类型”，它显然表示与标签相关联的数据的类型。 目前有9种：

```
	Type		Number
	----		------
	NULL		0
	CHAR		1
	INT8		2
	INT16		3
	INT32		4
	INT64		5
	STRING		6
	BIN		7
	STRING_ARRAY	8
	I18NSTRING_TYPE	9
```

最后一条信息是与每个标签一起存储的“计数”，并指示存储的相关类型的项目的数量。 作为一种特殊情况，STRING 类型的计数不允许大于 1。要存储多个字符串，您必须使用 STRING_ARRAY。

总而言之，标签、类型、计数和数据称为“Entry”或“Header Entry”。

```
00000000: 8e ad e8 01 00 00 00 00    ........
```

header以 3 个字节的魔法“8e ad e8”和一个指示header版本的字节开头。接下来的四个字节 (4-7) 被保留。

```
00000008: 00 00 00 20 00 00 07 77    ........
```

接下来的四个字节 (8-11) 形成一个 int32，它是存储的条目数的计数（在本例中为 32）。 字节 12-15 形成一个 int32，它是存储的数据字节数的计数（即每个条目的数据部分组成的字节数）。 在这种情况下，它是 1911 字节。

```
00000010: 00 00 03 e8 00 00 00 06 00 00 00 00 00 00 00 01    ................
```

在前 16 个字节之后是标头中称为“索引”的部分。 索引由“索引条目”组成，标题中的每个条目都有一个。 每个索引条目包含四个 int32 数量。 它们依次是：标签、类型、偏移量、计数。 在上面的例子中，我们有 tag=1000，type=6，offset=0，count=1。 通过查看 lib/rpmlib.h 中的标签，我们可以看到该条目是用于包名称的。 条目的类型是 STRING。 偏移量是从标头的数据部分开始到与该条目关联的数据的偏移量。 计数表明只有一个字符串与条目相关联（我们确实已经知道，因为不允许 STRING 类型的计数大于 1）。

在我们的示例中，将有 32 个这样的 16 字节索引条目，然后是数据部分：

```
00000210: 72 70 6d 00 32 2e 31 2e 32 00 31 00 52 65 64 20    rpm.2.1.2.1.Red 
00000220: 48 61 74 20 50 61 63 6b 61 67 65 20 4d 61 6e 61    Hat Package Mana
00000230: 67 65 72 00 31 e7 cb b4 73 63 68 72 6f 65 64 65    ger.1...schroede
00000240: 72 2e 72 65 64 68 61 74 2e 63 6f 6d 00 00 00 00    r.redhat.com....
...
00000970: 6c 69 62 63 2e 73 6f 2e 35 00 6c 69 62 64 62 2e    libc.so.5.libdb.
00000980: 73 6f 2e 32 00 00                                  so.2..
```

数据部分从字节 528 开始（4个magic，4个reserved，4个index条目count，4个数据字节count，16 * 32个索引条目）。在偏移量0处，字节528-531是“rpm”加上一个空字节，这是第一个索引条目（软件包名称）的数据。 以下是其他每个条目的数据。 每个字符串都是null终止的，STRING_ARRAY中的字符串也是null终止的，并且一个接一个地放置。整数类型与适当的字节边界对齐，因此 INT64 类型的数据从 8 字节边界开始，INT32 类型的数据从4字节边界开始，而INT16类型的数据从2字节边界开始。 例如：

```
00000060: 00 00 03 ef 00 00 00 06 00 00 00 28 00 00 00 01    ................
00000070: 00 00 03 f1 00 00 00 04 00 00 00 40 00 00 00 01    ................
...
00000240: 72 2e 72 65 64 68 61 74 2e 63 6f 6d 00 00 00 00    r.redhat.com....
00000250: 00 09 9b 31 52 65 64 20 48 61 74 20 4c 69 6e 75    ....Red Hat Linu
```

索引条目编号6是 STRING 类型的 BUILDHOST。 索引条目编号7是INT32类型的 SIZE。 条目编号6的相应数据在字节 588 处以“....redhat.com\0”结束。 下一条数据可能从字节 589 开始，该字节对于 INT32 来说是不正确的边界。 结果，插入了 3 个null字节，SIZE 的日期实际上从字节 592 开始：“00 09 9b 31”，即 629553）。

